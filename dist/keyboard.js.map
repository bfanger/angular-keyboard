{"version":3,"sources":["keyboard.module.js","undefined.js","directives/KbContainerController.js","directives/KbItemController.js","directives/kbItem.js","directives/kbList.js","directives/kbSelect.js","services/kbFocus.js","services/kbScrollTo.js"],"names":[],"mappings":"AAAA;CACC;CACA;CACA;CACA;CACA;CACA;CACA;CACA;AACD;ACTA;CACC;CACA;AACD;;ACHA,oCAAoC,qBAAqB,GAAG,sBAAA;IACxD;IACA;KACC;KACA;KACA;IACD;QACI;QACA;QACA;QACA;QACA;IACJ,CAAC;;IACD;QACI;;QAEA;SACC;SACA;SACA;QACD;YACI;YACA;gBACI;gBACA;oBACI;oBACA;wBACI;4BACI;wBACJ;wBACA;oBACJ;gBACJ;oBACI;gBACJ;gBACA;gBACA;oBACI;oBACA;wBACI;wBACA;oBACJ;gBACJ;YACJ;QACJ;;QAEA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;gBACI;oBACI;oBACA;gBACJ;YACJ;gBACI;gBACA;YACJ;QACJ;QACA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;YACA;gBACI;YACJ;QACJ;QACA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;gBACI;YACJ;gBACI;YACJ;QACJ;QACA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;QACJ;;QAEA;SACC;SACA;SACA;SACA;QACD;YACI;YACA;gBACI;gBACA;YACJ;YACA;QACJ;;QAEA;SACC;SACA;SACA;SACA;QACD;YACI;YACA;gBACI;gBACA;YACJ;YACA;QACJ;;QAEA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;YACA;QACJ;;QAEA;SACC;SACA;SACA;SACA;QACD;YACI;YACA;QACJ;;QAEA;SACC;SACA;SACA;QACD;YACI;YACA;gBACI;gBACA;oBACI;gBACJ;YACJ;QACJ;QACA;SACC;SACA;SACA;SACA;SACA;QACD;YACI;YACA;YACA;gBACI;gBACA;oBACI;oBACA;wBACI;oBACJ;oBACA;wBACI;oBACJ;oBACA;gBACJ;YACJ;YACA;QACJ;QACA;SACC;SACA;SACA;QACD;YACI;YACA;gBACI;YACJ;QACJ;IACJ;IACA;AACJ,CAAC,CAAA;ACpMD,oCAAoC,gBAAgB,GAAG,YAAA;IACnD;;IAEA;KACC;KACA;KACA;KACA;IACD;KACC;IACD,CAAC;;;IAED;KACC;MACC;YACM;KACP;IACD;IACA;;AAEJ,CAAC,CAAA;;ACpBD;CACC;CACA;AACD,sCAAsC,MAAM,GAAG,yCAAA;IAC3C;IACA;QACI;QACA;QACA;YACI;YACA;YACA;gBACI;oBACI;gBACJ;YACJ;YACA;gBACI;gBACA;YACJ;;YAEA;YACA;;YAEA;YACA;YACA;gBACI;YACJ;;YAEA;gBACI;YACJ;gBACI;YACJ;YACA;gBACI;YACJ;gBACI;oBACI;gBACJ;oBACI;gBACJ;YACJ;YACA;gBACI;YACJ;gBACI;oBACI;oBACA;gBACJ;oBACI;oBACA;wBACI;oBACJ;wBACI;oBACJ;gBACJ;YACJ;;YAEA;aACC;aACA;aACA;aACA;aACA;aACA;aACA;YACD;gBACI;oBACI;gBACJ;gBACA;oBACI;gBACJ;gBACA;oBACI;gBACJ;gBACA;oBACI;gBACJ;gBACA;YACJ;YACA;YACA;gBACI;gBACA;gBACA;gBACA;YACJ;YACA;gBACI;gBACA;oBACI;oBACA;oBACA;wBACI;wBACA;oBACJ;oBACA;wBACI;wBACA;oBACJ;gBACJ;oBACI;gBACJ;gBACA;oBACI;oBACA;gBACJ;YACJ;YACA;gBACI;gBACA;gBACA;YACJ;YACA;eACG;YACH;QACJ;IACJ;AACJ,CAAC,CAAA;;ACzHD;CACC;CACA;CACA;CACA;CACA;AACD,sCAAsC,MAAM,GAAG,oCAAA;IAC3C;;IAEA;QACI;QACA;QACA;YACI;YACA;gBACI;gBACA;gBACA;oBACI;oBACA;oBACA;gBACJ;gBACA;oBACI;gBACJ;;YAEJ;QACJ;IACJ;AACJ,CAAC,CAAA;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;CACC;CACA;CACA;CACA;CACA;AACD,sCAAsC,QAAQ,GAAG,0BAAA;IAC7C;;IAEA;QACI;QACA;QACA;YACI;;YAEA;gBACI;gBACA;gBACA;gBACA;oBACI;oBACA;gBACJ;gBACA;oBACI;oBACA;gBACJ;YACJ;QACJ;IACJ;AACJ,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;CACC;CACA;AACD,oCAAoC,OAAO,GAAG,eAAA;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI;YACQ;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;QACJ;;AAER;YACY;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;;AAEZ;IACI;KACC;KACA;KACA;IACD;AACJ;AACA;AACA;;QAEQ;;IAEJ;AACJ,CAAC,CAAA;ACtED;CACC;CACA;AACD,oCAAoC,UAAU,GAAG,YAAA;;IAE7C;IACA;IACA;QACI;IACJ;;IAEA;KACC;KACA;KACA;KACA;KACA;KACA;KACA;KACA;IACD;QACI;YACI;YACA;YACA;YACA;YACA;gBACI;YACJ;QACJ;YACI;YACA;QACJ;IACJ;;IAEA;KACC;KACA;KACA;KACA;KACA;KACA;IACD;QACI;QACA;QACA;YACI;YACA;YACA;gBACI;YACJ;YACA;QACJ;QACA;QACA;YACI;YACA;YACA;YACA;QACJ;QACA;QACA;YACI;gBACI;gBACA;gBACA;gBACA;YACJ;QACJ;YACI;YACA;gBACI;gBACA;gBACA;gBACA;YACJ;QACJ;AACR;;QAEQ;QACA;QACA;QACA;;QAEA;YACI;YACA;YACA;QACJ;YACI;YACA;YACA;QACJ;QACA;YACI;YACA;YACA;QACJ;YACI;YACA;YACA;QACJ;QACA;YACI;QACJ;QACA;QACA;YACI;YACA;QACJ;IACJ;IACA;AACJ,CAAC,CAAA","file":"keyboard.js","sourcesContent":["/**\n * angular-keyboard\n *\n * Keyboard behavior for AngularJS Webapps\n *\n *\n * Inspired by: Apple Mail\n * Implementation inspirated by: WinJS ListView http://try.buildwinjs.com/pages/listview/options/default.html\n */\nangular.module('keyboard', []);","/**\n * Register 'undefined' with the `undefined` value.\n */\nangular.module('keyboard').constant('undefined');\n","angular.module('keyboard').factory('KbContainerController', function (undefined, $log) {\n    'use strict';\n    /**\n     * @class KbListController\n     * @ngInject @param {jQElement} $element\n     */\n    function KbContainerController($element) {\n        this.ngModel = undefined;\n        this.selected = []; // Selected kbItem(s)\n        this.multiple = false;\n        this.active = undefined; // kbItemController of the active kb-item.\n        this._element = $element[0];\n    }\n    angular.extend(KbContainerController.prototype, {\n        /** @lends kbListController */\n\n        /**\n         *\n         * @param {Object} options\n         */\n        initialize: function (options) {\n            angular.extend(this, options);\n            this.ngModel.$render = function () {\n                // Change the selection to model.\n                if (this.multiple) {\n                    this.selected = this.ngModel.$viewValue;\n                    if (angular.isArray(this.selected) === false) {\n                        if (angular.isDefined(this.selected)) {\n                            $log.error(this.identifier, 'ng-model(multiple) must be an array, got:', this.selected);\n                        }\n                        this.selected = [];\n                    }\n                } else {\n                    this.selected[0] = this.ngModel.$viewValue;\n                }\n                // Activate the first item in the selection.\n                for (var i in this.selected) {\n                    var kbItem = this._locate(this.selected[i]);\n                    if (kbItem) {\n                        this.active = kbItem;\n                        break;\n                    }\n                }\n            }.bind(this);\n        },\n\n        /**\n         * Select the given model.\n         * Or in multiselect mode, add the given model to the selection.\n         *\n         * @param {*} model\n         */\n        select: function (model) {\n            if (this.multiple) {\n                if (this.isSelected(model) === false) {\n                    this.selected.push(model);\n                    this.ngModel.$setViewValue(this.selected);\n                }\n            } else {\n                this.selected[0] = model;\n                this.ngModel.$setViewValue(model);\n            }\n        },\n        /**\n         * Deselect the given model.\n         * Does nothing if the given model isn't selected.\n         *\n         * @param {*} model\n         */\n        deselect: function (model) {\n            var index = this.selected.indexOf(model);\n            if (index !== -1) {\n                this.selected.splice(index, 1);\n            }\n        },\n        /**\n         * Select or deselect the given model.\n         * Or in multiselect mode, adds or removes the given model to the selection.\n         *\n         * @param {*} model\n         */\n        toggle: function (model) {\n            if (this.isSelected(model)) {\n                this.deselect(model);\n            } else {\n                this.select(model);\n            }\n        },\n        /**\n         * Check if the given model is selected.\n         *\n         * @param {*} model\n         * @returns {Boolean}\n         */\n        isSelected: function (model) {\n            return (this.selected.indexOf(model) !== -1);\n        },\n\n        /**\n         * Activate the previous item.\n         *\n         * @returns {Boolean}\n         */\n        previous: function () {\n            var prev = this._getSiblingItems(this.active).previous;\n            if (prev) {\n                this.active = prev;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Activate the next item.\n         *\n         * @returns {Boolean}\n         */\n        next: function () {\n            var next = this._getSiblingItems(this.active).next;\n            if (next) {\n                this.active = next;\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Abstract method for when an item is clicked, moved to with the keys.\n         * @param {KbItemController} kbItem\n         * @param {Object} options\n         * @returns {Boolean}\n         */\n        activate: function (kbItem, options) {\n            $log.$error(this.identifier, 'activate() is not implemented');\n            return false;\n        },\n\n        /**\n         * Abstract method when an item is clicked or when space or enter is pressed.\n         * @param {KbItemController} kbItem  The active item.\n         * @returns {Boolean}\n         */\n        invoke: function (kbItem) {\n            $log.$error(this.identifier, 'invoke() is not implemented');\n            return false;\n        },\n\n        /**\n         * Returns the (first) kbItemController  which has the given model value.\n         * @returns {KbItemController}\n         */\n        _locate: function (model) {\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var kbItem = angular.element(items.item(i)).controller('kbItem');\n                if (kbItem.model === model) {\n                    return kbItem;\n                }\n            }\n        },\n        /**\n         * Returns the element, controller and models from the current, prevous and next item.\n         *\n         * @param {KbItemController} kbItem\n         * @returns {Object} with up to 2 KbItemControllers: previous and next.\n         */\n        _getSiblingItems: function (kbItem) {\n            var element = kbItem.element[0];\n            var items = this._element.querySelectorAll('[kb-item]');\n            for (var i = 0; i < items.length; i++) {\n                var el = items.item(i);\n                if (el === element) {\n                    var siblings = {};\n                    if (i !== 0) {\n                        siblings.previous = angular.element(items.item(i - 1)).controller('kbItem');\n                    }\n                    if (i < items.length - 1) {\n                        siblings.next = angular.element(items.item(i + 1)).controller('kbItem');\n                    }\n                    return siblings;\n                }\n            }\n            return {};\n        },\n        /**\n         * Returns the first item.\n         * @returns {kbItemController}\n         */\n        _first: function () {\n            var el = this._element.querySelector('[kb-item]');\n            if (el) {\n                return el.controller('kbItem');\n            }\n        }\n    });\n    return KbContainerController;\n});","angular.module('keyboard').factory('KbItemController', function (kbFocus) {\n    'use strict';\n\n    /**\n     * @class KbItemController\n     * @param {jQElement} $element\n     * @ngInject\n     */\n    function KbItemController($element) {\n    \tthis.element = $element;\n    }\n\n    angular.extend(KbItemController.prototype, {\n    \tfocus: function () {\n    \t\tthis.element.attr('tabindex', 0);\n            kbFocus(this.element);\n    \t}\n    });\n    return KbItemController;\n\n});\n","/**\n * kb-item\n */\nangular.module('keyboard').directive('kbItem', function (KbItemController, $animate, $log) {\n    'use strict';\n    return {\n        controller: KbItemController,\n        require: ['kbItem', '?^kbList', '?^kbSelect'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbItem = controllers[0];\n            var kbContainer = controllers[1];\n            for (var i = 1; i < controllers.length; i++) {\n                if (controllers[i]) {\n                    kbContainer = controllers[i];\n                }\n            }\n            if (!kbContainer) {\n                $log.error(\"Controller 'kbList' or 'kbSelect', required by directive 'kbItem', can't be found!\");\n                return;\n            }\n\n            var selectedClass = attrs.kbSelectedClass || 'kb-selected';\n            var activeClass = attrs.kbActiveClass || 'kb-active';\n\n            // Bind the model\n            kbItem.model = $scope.$eval(attrs.kbItem);\n            $scope.$watch(attrs.kbItem, function (model) {\n                kbItem.model = model;\n            });\n\n            if (typeof kbContainer.active === 'undefined') {\n                kbContainer.active = kbItem;\n            } else if (kbContainer.isSelected(kbItem.model) && kbContainer.isSelected(kbContainer.active.model) === false) {\n                kbContainer.active = kbItem;\n            }\n            $scope.$watch(function () {\n                return kbContainer.isSelected(kbItem.model);\n            }, function (isSelected) {\n                if (isSelected) {\n                    $animate.addClass(el, selectedClass);\n                } else {\n                    $animate.removeClass(el, selectedClass);\n                }\n            });\n            $scope.$watch(function () {\n                return kbContainer.active === kbItem;\n            }, function (isActive) {\n                if (isActive) {\n                    el.attr('tabindex', 0);\n                    $animate.addClass(el, activeClass);\n                } else {\n                    $animate.removeClass(el, activeClass);\n                    if (el.is('a') || el.is('button')) {\n                        el.attr('tabindex', 0);\n                    } else {\n                        el.removeAttr('tabindex');\n                    }\n                }\n            });\n\n            /**\n             * Calculates the distance to the ClientRect in a given direction.\n             * Allows for keyboard navigation based on the relative visual location of the element.\n             *\n             * @param {string} direction 'up', 'left', 'right' or 'down',\n             * @param {ClientRect} currentRect The position of the current item.\n             * @return {Number}\n             */\n            function distance(direction, currentRect, targetRect) {\n                if (direction === 'left' && targetRect.left < currentRect.left) {\n                    return currentRect.left - targetRect.left;\n                }\n                if (direction === 'up' && targetRect.top < currentRect.top) {\n                    return currentRect.top - targetRect.top;\n                }\n                if (direction === 'right' && targetRect.left > currentRect.left) {\n                    return targetRect.left - currentRect.left;\n                }\n                if (direction === 'down' && targetRect.top > currentRect.top) {\n                    return targetRect.top - currentRect.top;\n                }\n                return 0;\n            }\n            // { e.which: direction }\n            var directions = {\n                37: 'left',\n                38: 'up',\n                39: 'right',\n                40: 'down'\n            };\n            el.on('keydown', function (e) {\n                var changed = false;\n                if (e.which >= 37 && e.which <= 40) { // An arrow-key?\n                    var siblings = kbContainer._getSiblingItems(kbItem);\n                    var currentRect = el[0].getBoundingClientRect();\n                    if (siblings.previous && distance(directions[e.which], currentRect, siblings.previous.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.previous);\n                        changed = true;\n                    }\n                    if (siblings.next && distance(directions[e.which], currentRect, siblings.next.element[0].getBoundingClientRect())) {\n                        kbContainer.activate(siblings.next);\n                        changed = true;\n                    }\n                } else if (e.which === 32 || e.which === 13) { // Space || Enter\n                    changed = kbContainer.invoke(kbItem);\n                }\n                if (changed) {\n                    e.preventDefault();\n                    $scope.$apply();\n                }\n            });\n            el.on('click', function () {\n                kbContainer.activate(kbItem);\n                kbContainer.invoke(kbItem);\n                $scope.$apply();\n            });\n            $scope.$on('$destroy', function () {\n               kbContainer.active = kbContainer._first();\n            });\n        }\n    };\n});\n","/**\n * kb-list directive\n *\n * Usage:\n * <div kb-list ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbList', function (KbContainerController, $parse) {\n    'use strict';\n\n    return {\n        controller: KbContainerController,\n        require: ['kbList', 'ngModel'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n            kbContainer.initialize({\n                identifier: '[kb-list]',\n                ngModel: controllers[1],\n                activate: function (kbItem) {\n                    this.active = kbItem;\n                    this.select(kbItem.model);\n                    kbItem.focus();\n                },\n                invoke: function () {\n                    return false;\n                }\n\n            });\n        }\n    };\n});\n//            var getModal =ter = $parse(attrs.attrs);\n\n//            ngModel.$render = function () {\n//                if (kbContainer.mode === 'multiselect') {\n//                    kbContainer.selected = angular.isArray(ngModel.$viewValue) ? ngModel.$viewValue : [];\n//                    for (var i in kbContainer.selected) {\n//                        var kbItem = kbContainer._locate(kbContainer.selected[i]);\n//                        if (kbItem) {\n//                            kbContainer.active = kbItem;\n//                            break;\n//                        }\n//                    }\n//                } else {\n//                    kbContainer.selected[0] = ngModel.$viewValue;\n//                    var kbItem = kbContainer._locate(kbContainer.selected[0]);\n//                    if (kbItem) {\n//                        kbContainer.active = kbItem;\n//                    }\n//                }\n//            };\n//            $scope.$watch(function () {\n//                return kbContainer.selected;\n//            }, function (selected) {\n//                if (kbContainer.mode === 'multiselect') {\n////                    ngModel.$setViewValue(selected);\n//                } else {\n////                    ngModel.$setViewValue(selected[0]);\n//                }\n//            });\n","/**\n * kb-select directive\n *\n * Usage:\n * <div kb-select ng-model=\"selection\"> ... <div kb-item=\"aItem\">...</div> ... </div>\n */\nangular.module('keyboard').directive('kbSelect', function (KbContainerController) {\n    'use strict';\n\n    return {\n        controller: KbContainerController,\n        require: ['kbSelect', 'ngModel'],\n        link: function ($scope, el, attrs, controllers) {\n            var kbContainer = controllers[0];\n\n            kbContainer.initialize({\n                identifier: '[kb-select]',\n                ngModel: controllers[1],\n                multiple: angular.isDefined(attrs.multiple),\n                activate: function (kbItem) {\n                    this.active = kbItem;\n                    kbItem.focus();\n                },\n                invoke: function (kbItem) {\n                    this.toggle(kbItem.model);\n                    return true;\n                }\n            });\n        }\n    };\n});\n//            ngModel.$render = function () {\n//                if (kbContainer.mode === 'multiselect') {\n//                    kbContainer.selected = angular.isArray(ngModel.$viewValue) ? ngModel.$viewValue : [];\n//                    for (var i in kbContainer.selected) {\n//                        var kbItem = kbContainer._locate(kbContainer.selected[i]);\n//                        if (kbItem) {\n//                            kbContainer.active = kbItem;\n//                            break;\n//                        }\n//                    }\n//                } else {\n//                    kbContainer.selected[0] = ngModel.$viewValue;\n//                    var kbItem = kbContainer._locate(kbContainer.selected[0]);\n//                    if (kbItem) {\n//                        kbContainer.active = kbItem;\n//                    }\n//                }\n//            };\n//            $scope.$watch(function () {\n//                return kbContainer.selected;\n//            }, function (selected) {\n//                if (kbContainer.mode === 'multiselect') {\n////                    ngModel.$setViewValue(selected);\n//                } else {\n////                    ngModel.$setViewValue(selected[0]);\n//                }\n//            });\n","/**\n * Focus an element, but\n */\nangular.module('keyboard').factory('kbFocus', function (kbScrollTo) {\n//    var duration = 150;\n//    var cancelAnimation = angular.noop;\n//    function scrollTo(el, _isFocusEvent) {\n//        // Wrapped in a timeout, prevents issues with focus & click events and scrolls to the last activated kb-item.\n//        $timeout.cancel(timer);\n//        if (_isFocusEvent) {\n//            timer = $timeout(function () {\n//                cancelAnimation();\n//                cancelAnimation = kbScrollTo(el[0], {top: 0, right: 0, bottom: 0, left: 0}, 0);\n//            }, 100, false);\n//        } else {\n//            cancelAnimation();\n//            cancelAnimation = kbScrollTo(el[0], {top: 0, right: 0, bottom: 0, left: 0}, 150);\n//        }\n//    }\n    // var focusClass = attrs.kbFocusClass || 'kb-focus';\n            // $scope.$watch(function () {\n            //     return kbList.focus === kbItem.getModel();\n            // }, function (hasFocus) {\n            //     if (hasFocus) {\n            //         $animate.addClass(el, focusClass);\n            //         scrollTo(el, kbList._isFocusEvent);\n            //     } else {\n            //         $animate.removeClass(el, focusClass);\n            //     }\n            // });\n        var timer = null;\n\n// if (angular.isUndefined(el.attr('tabindex'))) {\n            //     el.attr('tabindex', 0);\n            // }\n            // el.on('click', function () {\n            //     if (document.activeElement !== this) { // not(:focus) ?\n            //         // In Internet Explorer a click doesn't focus containers. ><\n            //         el.focus();\n            //     }\n            // });\n            // el.on('focus', function (e) {\n            //     kbList._isFocusEvent = true;\n            //     if (angular.isUndefined(kbList.active)) {\n            //         kbList.active = kbList.first().model;\n            //     }\n            //     kbList.focus = kbList.active;\n            //     hasFocus = true;\n            //     $scope.$apply();\n            //     kbList._isFocusEvent = false;\n            // });\n            // el.on('blur', function () {\n            //     kbList.focus = null;\n            //     hasFocus = false;\n            //     $scope.$apply();\n            // });\n\n//    var cancel = angular.noop;\n    /**\n     *\n     * @param {Element} el\n     */\n    return function(el) {\n//        console.log(el);\n//        cancel();\n//        cancel = kbScrollTo(el)\n\n        el.focus();\n\n    };\n});","/**\n * Helper for scrolling an element into the viewable area.\n */\nangular.module('keyboard').factory('kbScrollTo', function ($window) {\n\n    // Most browsers scroll via scrollTop on the <body> element.\n    var viewportNode = 'BODY';\n    if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {\n        viewportNode = 'HTML'; // Except Firefox, which uses scrollTop on <html> element.\n    }\n\n    /**\n     * Change the scrollposition animated and return a function that cancels the animation.\n     *\n     * @param {Element} container\n     * @param {String} property 'scrollTop' or 'scrollLeft'\n     * @param {Number} value\n     * @param {Number} duration\n     * @returns {Function}\n     */\n    function change(container, property, value, duration) {\n        if (duration && angular.element.prototype.animate) { // jQuery.animate is available?\n            var el = angular.element(container);\n            var props = {};\n            props[property] = value;\n            el.animate(props, duration);\n            return function () {\n                el.stop(true, true);\n            };\n        } else {\n            container[property] = value;\n            return angular.noop;\n        }\n    }\n\n    /**\n     *\n     * @param {Element} el  The DOMElement\n     * @param {Object} offset  Allowed hidden\n     * @param {Number} duration  Duration of the animation in ms\n     * @returns {Function} cancel animation\n     */\n    function kbScrollTo(el, offset, duration) {\n        var cancelAnimation = angular.noop;\n        var parent = el.parentElement;\n        while (parent.nodeName !== viewportNode) {\n            var parentStyle = getComputedStyle(parent);\n            var overflowStyle = parentStyle.overflow + parentStyle.overflowX + parentStyle.overflowY;\n            if (overflowStyle.match(/scroll|hidden/)) {\n                break;\n            }\n            parent = parent.parentElement;\n        }\n        var elRect = el.getBoundingClientRect();\n        var pos = {\n            top: Math.ceil(elRect.top),\n            right: Math.ceil(elRect.right),\n            bottom: Math.ceil(elRect.bottom),\n            left: Math.ceil(elRect.left)\n        };\n        // @todo Add outline-width to pos\n        if (parent.nodeName === viewportNode) {\n            var parentPos = {\n                top: 0,\n                right: $window.innerWidth,\n                bottom: $window.innerHeight,\n                left: 0\n            };\n        } else {\n            var parentRect = parent.getBoundingClientRect();\n            var parentPos = {\n                top: Math.ceil(parentRect.top),\n                right: Math.ceil(parentRect.right),\n                bottom: Math.ceil(parentRect.bottom),\n                left: Math.ceil(parentRect.left)\n            };\n        }\n//        console.info(el.nodeName, pos, 'in', parent.nodeName, parentPos, 'offset', offset);\n\n        var relTop = pos.top - parentPos.top;\n        var relRight = parentPos.right - pos.right;\n        var relBottom = parentPos.bottom - pos.bottom;\n        var relLeft = pos.left - parentPos.left;\n\n        if (relTop + offset.top < 0) { // up\n            cancelAnimation = change(parent, 'scrollTop', parent.scrollTop + relTop + offset.top, duration);\n            relBottom += relTop;\n            relTop = 0;\n        } else if (relBottom + offset.bottom < 0) { // down\n            cancelAnimation = change(parent, 'scrollTop', parent.scrollTop - relBottom + offset.bottom, duration);\n            relTop += relBottom;\n            relBottom = 0;\n        }\n        if (relLeft + offset.left < 0) { // left\n            cancelAnimation = change(parent, 'scrollLeft', parent.scrollLeft + relLeft + offset.left, duration);\n            relRight += relLeft;\n            relLeft = 0;\n        } else if (relRight + offset.right < 0) { // right\n            cancelAnimation = change(parent, 'scrollLeft', parent.scrollLeft - relRight + offset.right, duration);\n            relLeft += relRight;\n            relRight = 0;\n        }\n        if (parent.nodeName === viewportNode) {\n            return cancelAnimation;\n        }\n        var cancelParentAnimation = kbScrollTo(parent, {top: relTop, right: relTop, bottom: relBottom, left: relLeft}, duration);\n        return function () {\n            cancelAnimation();\n            cancelParentAnimation();\n        };\n    }\n    return kbScrollTo;\n});\n"],"sourceRoot":"/source/"}